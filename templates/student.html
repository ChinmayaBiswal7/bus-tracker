<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student Tracker</title>
    <!-- Leaflet CSS -->
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet Routing Machine -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>

    <!-- PWA Setup -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#0f172a">
    <script>
        // Emergency Service Worker Reset (Fix for v4/v5 conflict)
        const SW_RESET_KEY = 'sw_reset_perf_v1';
        if (!localStorage.getItem(SW_RESET_KEY)) {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    for (let registration of registrations) {
                        console.log("Unregistering old SW:", registration);
                        registration.unregister();
                    }
                    // Clear Caches
                    caches.keys().then(names => {
                        for (let name of names) caches.delete(name);
                    });

                    localStorage.setItem(SW_RESET_KEY, 'true');
                    console.log("Service Workers & Cache Reset. Reloading...");
                    window.location.reload();
                });
            }
        }

        // PWA Install Logic
        let deferredPrompt;
        window.addEventListener('load', () => {
            const installBtn = document.getElementById('install-btn');

            window.addEventListener('beforeinstallprompt', (e) => {
                // Prevent Chrome 67 and earlier from automatically showing the prompt
                e.preventDefault();
                // Stash the event so it can be triggered later.
                deferredPrompt = e;
                // Update UI to notify the user they can add to home screen
                if (installBtn) installBtn.classList.remove('hidden');
                console.log("PWA Install Prompt ready");
            });

            if (installBtn) {
                installBtn.addEventListener('click', async () => {
                    if (deferredPrompt) {
                        deferredPrompt.prompt();
                        const { outcome } = await deferredPrompt.userChoice;
                        console.log(`User response to the install prompt: ${outcome}`);
                        deferredPrompt = null;
                        installBtn.classList.add('hidden');
                    }
                });
            }

            window.addEventListener('appinstalled', () => {
                if (installBtn) installBtn.classList.add('hidden');
                deferredPrompt = null;
                console.log('PWA was installed');
            });
        });

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(reg => console.log('SW Registered!', reg.scope))
                    .catch(err => console.log('SW Failed:', err));
            });
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Outfit', sans-serif;
        }

        #map {
            height: 100vh;
            width: 100%;
            z-index: 1;
            /* Dark Mode Map Filter */
            filter: invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%);
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
        }

        /* Prevent map controls from being inverted */
        .leaflet-control-container {
            filter: invert(100%) hue-rotate(180deg) brightness(105%) contrast(110%);
        }

        .pulse-ring {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            border-radius: 9999px;
            box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            /* Blue-500 */
            animation: pulse-blue 2s infinite;
            z-index: -1;
        }

        @keyframes pulse-blue {
            0% {
                transform: translate(-50%, -50%) scale(0.95);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            }

            70% {
                transform: translate(-50%, -50%) scale(2);
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }

            100% {
                transform: translate(-50%, -50%) scale(0.95);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }

        /* Ensure User Marker is visible */
        .custom-user-icon {
            z-index: 1000 !important;
        }

        /* GPS Status Indicator (Processed by Tailwind Classes now) */
        #gps-status {
            /* Styles moved to internal div classes */
        }
    </style>
</head>

<body class="h-screen w-screen overflow-hidden relative bg-slate-900" style="display: none;" id="main-body">
    <!-- Auth Guard -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

        const guardConfig = {
            apiKey: "AIzaSyAW7XS_Q_Kdh2eiYEaKBEHvZDpOk7-ynDg",
            authDomain: "bustracker-c0af6.firebaseapp.com",
            projectId: "bustracker-c0af6",
            storageBucket: "bustracker-c0af6.firebasestorage.app",
            messagingSenderId: "103145940746",
            appId: "1:103145940746:web:80a8444bff23e75b94fcf3",
            measurementId: "G-PKF72NB657"
        };

        const guardApp = initializeApp(guardConfig);
        window.firebaseApp = guardApp;
        const auth = getAuth(guardApp);

        onAuthStateChanged(auth, (user) => {
            if (user) {
                // User is signed in
                console.log("Auth Guard: User is logged in", user.email);
                document.getElementById('main-body').style.display = 'block';
                // Update username
                const nameEl = document.getElementById('user-display-name');
                if (nameEl) nameEl.textContent = user.displayName || user.email.split('@')[0];

                // Fix Leaflet sizing issue (Robust Retry)
                let attempts = 0;
                const resizeInterval = setInterval(() => {
                    attempts++;
                    if (window.map) {
                        window.map.invalidateSize();
                        console.log("Map resized successfully");
                        clearInterval(resizeInterval);
                    }
                    if (attempts > 30) clearInterval(resizeInterval); // Stop after 3s
                }, 100);
            } else {
                // No user is signed in
                console.log("Auth Guard: No user, redirecting...");
                window.location.href = '/login?role=student';
            }
        });

        window.logout = function () {
            auth.signOut().then(() => {
                window.location.href = '/';
            }).catch((error) => {
                console.error("Logout failed:", error);
            });
        }
    </script>

    <!-- Top Navigation Bar (Task Bar) -->
    <header
        class="fixed top-0 left-0 w-full h-16 z-[2000] bg-slate-900/95 backdrop-blur-xl border-b border-slate-700 flex items-center justify-between px-4 shadow-lg text-white">

        <!-- Left: Menu & Brand -->
        <div class="flex items-center gap-3">
            <button onclick="toggleSidebar()"
                class="p-2 -ml-2 text-slate-300 hover:text-white hover:bg-white/10 rounded-full transition-colors">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16">
                    </path>
                </svg>
            </button>
            <h1 class="text-lg font-bold text-white tracking-tight hidden sm:block">Campus Ride</h1>
        </div>

        <!-- Right: Status Indicators -->
        <div class="flex items-center gap-3">
            <!-- Debug (Collapsible/Icon on mobile?) -->
            <div id="debug-status"
                class="hidden md:block px-3 py-1 bg-slate-800 text-slate-300 text-[10px] font-mono rounded-full border border-slate-700">
                Checking...
            </div>

            <!-- Status Badges -->
            <div class="flex items-center gap-2">
                <div class="flex items-center gap-1.5 bg-slate-800/80 px-2.5 py-1 rounded-full border border-slate-700">
                    <span class="w-1.5 h-1.5 rounded-full bg-yellow-500 animate-pulse" id="gps-dot"></span>
                    <span class="text-[10px] font-bold text-slate-200" id="gps-text">Locating</span>
                </div>
                <div class="flex items-center gap-1.5 bg-slate-800/80 px-2.5 py-1 rounded-full border border-slate-700">
                    <span class="w-1.5 h-1.5 rounded-full bg-red-500" id="server-dot"></span>
                    <span class="text-[10px] font-bold text-slate-200" id="server-text">Offline</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content Area (Map) -->
    <!-- Adjusted height to account for 4rem (h-16) header -->
    <div id="map" class="absolute top-16 left-0 right-0 bottom-0 z-0 h-[calc(100%-4rem)]"></div>

    <!-- Trip Info Card (Compact Pill) -->
    <div id="trip-info-card"
        class="fixed bottom-24 left-1/2 -translate-x-1/2 bg-blue-600 text-white px-6 py-3 rounded-full shadow-[0_0_20px_rgba(37,99,235,0.5)] z-[900] hidden flex items-center gap-4 transition-all duration-300 transform scale-100 border border-blue-400/50 backdrop-blur-md">
        <div class="flex flex-col items-start leading-tight">
            <span class="text-[10px] font-bold opacity-90 uppercase tracking-widest">Arrival</span>
            <span id="trip-eta" class="text-lg font-bold font-mono">-- min</span>
        </div>
        <div class="h-8 w-px bg-white/20"></div>
        <div class="flex flex-col items-start leading-tight">
            <span class="text-[10px] font-bold opacity-90 uppercase tracking-widest">Dist</span>
            <span id="trip-dist" class="text-sm font-mono opacity-90">-- km</span>
        </div>
        <button onclick="stopTrackingRoute()"
            class="bg-white/10 hover:bg-white/20 rounded-full p-1.5 ml-1 transition-colors">
            <svg class="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
        </button>
    </div>

    <!-- Sidebar (Off-Canvas) -->
    <div id="sidebar" class="fixed inset-y-0 left-0 w-80 z-[2000] transform -translate-x-full transition-transform duration-300 ease-in-out
                bg-slate-900/95 backdrop-blur-xl border-r border-slate-700 p-5 text-white flex flex-col shadow-2xl">

        <!-- Header & Nav -->
        <!-- Header & Nav -->
        <div class="flex items-center justify-between mb-4 shrink-0">
            <div class="flex items-center gap-2">
                <button onclick="logout()" class="p-2 -ml-2 hover:bg-white/10 rounded-full transition-colors"
                    title="Logout">
                    <svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7">
                        </path>
                    </svg>
                </button>
                <h1 class="font-bold text-xl tracking-tight">Campus Ride</h1>
            </div>
            <button onclick="toggleSidebar()" class="p-2 hover:bg-white/10 rounded-full transition-colors">
                <svg class="w-5 h-5 text-slate-400 hover:text-white" fill="none" stroke="currentColor"
                    viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                    </path>
                </svg>
            </button>
        </div>

        <p class="text-xs text-slate-400 mb-4">Welcome, <span id="user-display-name"
                class="text-blue-400 font-bold">Student</span></p>

        <!-- Search -->
        <div class="relative mb-6 shrink-0">
            <input type="text" id="trackInput" placeholder="Find bus (e.g. 42)"
                class="w-full bg-slate-700/50 border border-slate-600 rounded-xl py-3 pl-4 pr-12 text-sm focus:outline-none focus:border-blue-500 transition-colors uppercase placeholder-slate-500 h-11">
            <button onclick="setFilter()"
                class="absolute right-1.5 top-1.5 bottom-1.5 bg-blue-600 hover:bg-blue-500 text-white rounded-lg px-4 text-xs font-bold transition-colors">
                GO
            </button>
        </div>



        <!-- Recommendations -->
        {% if recommendations %}
        <div class="mb-4 shrink-0">
            <p class="text-[10px] uppercase text-slate-500 font-bold mb-2 tracking-wider">Recommended for you</p>
            <div class="flex flex-wrap gap-2">
                {% for bus in recommendations %}
                <button onclick="quickSearch('{{ bus }}')"
                    class="px-3 py-1 bg-blue-900/40 border border-blue-700/50 hover:border-blue-500 rounded-lg text-xs text-blue-200 transition-all font-mono">
                    {{ bus }}
                </button>
                {% endfor %}
            </div>
        </div>
        {% endif %}

        <p id="tracking-status" class="text-xs text-blue-300 mb-2 hidden flex items-center gap-2 shrink-0">
            <span>Tracking:</span>
            <span id="fw-bold" class="font-bold text-white">All</span>
        </p>



        <!-- Bus List -->
        <div class="space-y-2 overflow-y-auto pr-1 flex-1 min-h-0 custom-scrollbar">
            <div id="bus-list" class="space-y-2">
                <p class="text-xs text-slate-500 text-center py-4 italic">Scanning for active buses...</p>
            </div>
        </div>

        <!-- Sidebar Menu Items -->
        <div class="space-y-2 mt-auto pt-4 border-t border-slate-700/50">
            <!-- PWA Install Button (Hidden by default) -->
            <button id="install-btn"
                class="w-full flex items-center gap-3 p-3 bg-blue-600/20 hover:bg-blue-600/30 rounded-xl border border-blue-500/50 transition-all hidden group mb-2">
                <div class="p-2 bg-blue-500 rounded-lg text-white group-hover:scale-110 transition-transform">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                </div>
                <div class="text-left">
                    <p class="font-bold text-blue-100 text-sm">Install App</p>
                    <p class="text-[10px] text-blue-300">Add to Home Screen</p>
                </div>
            </button>
            <button onclick="openAnnouncements()"
                class="w-full flex items-center justify-between p-3 bg-slate-800/50 hover:bg-slate-700/50 rounded-xl border border-slate-700 hover:border-blue-500/50 transition-all group">
                <div class="flex items-center gap-3">
                    <div
                        class="p-2 bg-amber-500/20 rounded-lg text-amber-500 group-hover:text-amber-400 transition-colors">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M11 5.882V19.24a1.76 1.76 0 01-3.417.592l-2.147-6.15M18 13a3 3 0 100-6M5.436 13.683A4.001 4.001 0 017 6h1.832c4.1 0 7.625-1.234 9.168-3v14c-1.543-1.766-5.067-3-9.168-3H7a3.988 3.988 0 01-1.564-.317z">
                            </path>
                        </svg>
                    </div>
                    <span class="font-bold text-slate-200 text-sm">Announcements</span>
                </div>
                <!-- Unread Badge -->
                <span id="badge-count"
                    class="hidden min-w-[20px] h-5 px-1.5 flex items-center justify-center bg-red-500 text-white text-[10px] font-bold rounded-full shadow-lg shadow-red-500/20 ring-2 ring-slate-900 transform scale-100 transition-all">0</span>
            </button>
        </div>
    </div>

    <!-- Announcements Overlay -->
    <div id="announcement-overlay"
        class="fixed inset-0 z-[3000] bg-slate-900/95 backdrop-blur-xl hidden flex flex-col transition-all duration-300 transform scale-100 opacity-100">
        <!-- Header -->
        <!-- Header -->
        <div class="p-4 border-b border-slate-800 flex items-center gap-2 bg-slate-900 shadow-xl shrink-0">
            <button onclick="closeAnnouncements()"
                class="p-2 -ml-2 hover:bg-slate-800 rounded-full text-slate-400 hover:text-white transition-colors"
                title="Back to Map">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
            </button>

            <button onclick="requestNotificationPermission()" id="btn-notify"
                class="p-2 hover:bg-slate-800 rounded-full text-slate-400 hover:text-white transition-colors mr-auto relative group"
                title="Enable Notifications">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9">
                    </path>
                </svg>
                <span id="notify-badge"
                    class="absolute top-1 right-1 w-2 h-2 bg-red-500 rounded-full animate-pulse"></span>
            </button>
            <h2 class="text-lg font-bold text-white tracking-tight ml-auto">Announcements</h2>
        </div>

        <!-- List -->
        <div id="full-announcement-list" class="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
            <!-- Items injected by JS -->
        </div>
    </div>

    <!-- Trip Info Card (GPS Tracking) -->
    <!-- ... (No changes here) ... -->

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Routing Machine -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <style>
        /* Hide the default instruction box of routing machine */
        .leaflet-routing-container {
            display: none !important;
        }
    </style>

    <!-- Firebase SDK & Logic -->
    <script type="module">
        import { getFirestore, collection, query, orderBy, limit, onSnapshot } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getMessaging, getToken, onMessage } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging.js";

        // Use the app instance from the Auth Guard
        const app = window.firebaseApp;
        const db = getFirestore(app);
        const messaging = getMessaging(app);

        // --- FCM Logic (Push Notifications) ---
        const VAPID_KEY = "BJoiF9u6UpFvBbNQcjByY3IfcxS9yivCpdcMS5b1jpg4rFoTnM35kZzmgEuVCWgJiBrcofsPLrjh4CoO5i1DZBE";

        async function initFCM() {
            try {
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    // Visual Debug: Success
                    const debugEl = document.getElementById('debug-status');
                    if (debugEl) debugEl.innerHTML = "ðŸ”” Perm: GRANTED";

                    // Wait for Service Worker (merged sw.js)
                    let registration;
                    if ('serviceWorker' in navigator) {
                        try {
                            registration = await navigator.serviceWorker.ready;
                        } catch (e) {
                            console.log("SW Ready Timeout/Error", e);
                        }
                    }

                    const token = await getToken(messaging, {
                        vapidKey: VAPID_KEY,
                        serviceWorkerRegistration: registration
                    });

                    if (token) {
                        console.log("ðŸ”¥ FCM Token:", token);
                        if (debugEl) debugEl.innerHTML = "ðŸ”¥ Token: OK";

                        // Send token to server to subscribe to 'news' topic
                        fetch('/subscribe', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ token: token }),
                        });
                    } else {
                        console.log("No registration token available.");
                        if (debugEl) debugEl.innerHTML = "âš ï¸ Token: MISSING";
                    }
                } else {
                    alert("Notifications Denied! Please reset permissions.");
                    const debugEl = document.getElementById('debug-status');
                    if (debugEl) debugEl.innerHTML = "âŒ Perm: DENIED";
                }
            } catch (err) {
                console.log('An error occurred while retrieving token. ', err);
            }
        }

        // Handle foreground messages
        onMessage(messaging, (payload) => {
            console.log('Message received. ', payload);
            sendNotification(payload.notification.title, payload.notification.body);
        });

        // Initialize FCM
        initFCM();

        // --- Notification Logic (Local) ---
        const notifyBtn = document.getElementById('btn-notify');
        const notifyBadge = document.getElementById('notify-badge');

        // Check initial state
        if (Notification.permission === 'granted') {
            notifyBadge.classList.add('hidden');
            notifyBtn.classList.add('text-green-400');
        }

        window.requestNotificationPermission = function () {
            if (Notification.permission === 'granted') {
                alert("Notifications are already enabled! ðŸ””");
                return;
            }

            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    notifyBadge.classList.add('hidden');
                    notifyBtn.classList.replace('text-slate-400', 'text-green-400');
                    new Notification("Notifications Enabled", {
                        body: "You will now receive alerts for new announcements!",
                        icon: "https://cdn-icons-png.flaticon.com/512/3233/3233914.png"
                    });
                }
            });
        };

        function sendNotification(title, body) {
            if (Notification.permission === 'granted') {
                new Notification(title, {
                    body: body,
                    icon: "https://cdn-icons-png.flaticon.com/512/3233/3233914.png"
                });
            }
        }



        // --- Refactored Announcement Logic (Hierarchical) ---
        // ... (badgeEl, overlayEl, listEl definitions same) ...

        const badgeEl = document.getElementById('badge-count');
        const overlayEl = document.getElementById('announcement-overlay');
        const listEl = document.getElementById('full-announcement-list');

        // 1. Listen for Active Buses (Categories)
        // Optimize: Limit to last 50 messages to fix slow loading
        const qBuses = query(collection(db, "announcements"), orderBy("last_updated", "desc"), limit(50));
        let activeBuses = [];
        let unsubscribeMessages = {}; // Store unsubscribe functions for message listeners

        onSnapshot(qBuses, (snapshot) => {
            activeBuses = [];

            snapshot.docChanges().forEach((change) => {
                if (change.type === "added" || change.type === "modified") {
                    const data = change.doc.data();
                    // Only notify if it's a recent update (prevent spam on reload)
                    const now = new Date();
                    const msgTime = data.last_updated ? data.last_updated.toDate() : new Date(); // Fallback to now if missing

                    // Aggressive Notification: Send popup even if app is open
                    // Relaxed check: 60 seconds to account for network/clock skew
                    if ((now - msgTime) < 60000) {
                        console.log("Triggering Notification for:", data.bus_no);
                        sendNotification(`ðŸ“¢ Bus ${data.bus_no}`, data.latest_message || "New announcement");
                    }
                }
            });

            snapshot.forEach(doc => {
                const data = doc.data();
                activeBuses.push({ id: doc.id, ...data });
            });
            updateBadge();

            // FIX: Refresh list if currently viewing
            if (!overlayEl.classList.contains('hidden')) {
                renderBusList();
            }
        });

        function updateBadge() {
            // ... (Same logic) ...
            if (!badgeEl) return;
            const lastReadStr = localStorage.getItem('lastReadTime');
            let unread = 0;

            if (!activeBuses.length) {
                badgeEl.classList.add('hidden');
                return;
            }

            if (!lastReadStr) {
                unread = activeBuses.length;
            } else {
                const lastRead = new Date(lastReadStr);
                unread = activeBuses.filter(bus => {
                    if (!bus.last_updated) return false;
                    return bus.last_updated.toDate() > lastRead;
                }).length;
            }

            if (unread > 0) {
                badgeEl.textContent = unread > 9 ? '9+' : unread;
                badgeEl.classList.remove('hidden');
            } else {
                badgeEl.classList.add('hidden');
            }
        }

        window.openAnnouncements = function () {
            // ... (Same) ...
            overlayEl.classList.remove('hidden');
            renderBusList();
            localStorage.setItem('lastReadTime', new Date().toISOString());
            updateBadge();
            if (window.innerWidth < 768) toggleSidebar();
        }

        window.closeAnnouncements = function () {
            overlayEl.classList.add('hidden');
        }

        function renderBusList() {
            const currentIds = new Set(activeBuses.map(b => b.id));

            // 1. Remove orphans (Buses that are no longer active)
            Array.from(listEl.children).forEach(child => {
                // Ensure we only touch bus containers
                if (!child.id.startsWith('bus-container-')) return;

                const id = child.id.replace('bus-container-', '');
                if (!currentIds.has(id)) {
                    if (unsubscribeMessages[id]) {
                        unsubscribeMessages[id]();
                        delete unsubscribeMessages[id];
                    }
                    child.remove();
                }
            });

            // 2. Clear empty message if we have buses
            if (activeBuses.length > 0) {
                const emptyMsg = listEl.querySelector('p.italic');
                if (emptyMsg) emptyMsg.remove();
            } else if (listEl.children.length === 0) {
                listEl.innerHTML = '<p class="text-slate-500 text-center italic mt-4">No active announcements channels.</p>';
                return;
            }

            // 3. Create or Update / Re-order
            activeBuses.forEach(bus => {
                const containerId = `bus-container-${bus.id}`;
                let container = document.getElementById(containerId);
                const busStr = bus.bus_no || bus.id;

                if (!container) {
                    // CREATE NEW
                    container = document.createElement('div');
                    container.className = "border border-slate-700 rounded-xl overflow-hidden mb-2 transition-all";
                    container.id = containerId;

                    // Header (Create initial structure)
                    const header = document.createElement('div');
                    header.className = "flex items-center justify-between p-4 bg-slate-800/80 hover:bg-slate-800 cursor-pointer";
                    header.onclick = () => toggleBusSection(bus.id);
                    container.appendChild(header);

                    // Content Area
                    const content = document.createElement('div');
                    content.id = `content-${bus.id}`;
                    content.className = "hidden bg-slate-900/50 p-4 space-y-3 min-h-[50px]";
                    content.innerHTML = '<div class="text-center text-xs text-slate-500 py-2"><span class="animate-pulse">Loading messages...</span></div>';
                    container.appendChild(content);
                }

                // UPDATE CONTENT (Header) - Safe to overwrite internal HTML of header
                // We preserve the header element itself, so onclick is safe.
                const header = container.firstElementChild;
                const isContentOpen = !container.lastElementChild.classList.contains('hidden');

                header.innerHTML = `
                    <div class="flex items-center gap-3">
                        <div class="w-8 h-8 rounded-full bg-blue-900/50 flex items-center justify-center text-xs">ðŸšŒ</div>
                        <span class="font-bold text-slate-200 text-sm">${busStr}</span>
                    </div>
                     <div class="flex items-center gap-2">
                        <span class="text-[10px] text-slate-500 italic">${bus.latest_message ? 'Active' : ''}</span>
                        <svg id="arrow-${bus.id}" class="w-5 h-5 text-slate-500 transform transition-transform ${isContentOpen ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </div>
                `;

                // RE-INSERT to ensure sort order (appendChild moves existing node)
                listEl.appendChild(container);
            });

        }

        window.toggleBusSection = function (busId) {
            // ... (Same) ...
            const content = document.getElementById(`content-${busId}`);
            const arrow = document.getElementById(`arrow-${busId}`);

            if (content.classList.contains('hidden')) {
                // Open
                content.classList.remove('hidden');
                arrow.classList.add('rotate-180');
                loadMessagesForBus(busId);
            } else {
                // Close
                content.classList.add('hidden');
                arrow.classList.remove('rotate-180');
            }
        }

        function loadMessagesForBus(busId) {
            if (unsubscribeMessages[busId]) return; // Already listening

            const contentDiv = document.getElementById(`content-${busId}`);
            const qMsgs = query(collection(db, "announcements", busId, "messages"), orderBy("timestamp", "desc"), limit(20));

            const unsub = onSnapshot(qMsgs, (snapshot) => {
                if (snapshot.empty) {
                    contentDiv.innerHTML = '<p class="text-xs text-slate-500 text-center italic">No messages yet.</p>';
                } else {
                    // Detect NEW messages for notifications
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            const data = change.doc.data();
                            // Logic: Only notify if timestamp is very recent (< 1 min ago)
                            // This prevents spamming on initial page load (history)
                            if (data.timestamp) {
                                const diff = new Date() - data.timestamp.toDate();
                                if (diff < 60000) { // 60 seconds
                                    sendNotification(`ðŸ“¢ Alert: ${busId}`, data.message);
                                }
                            }
                        }
                    });

                    contentDiv.innerHTML = ''; // Clear loading
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        renderMessage(contentDiv, data);
                    });
                }
            });

            unsubscribeMessages[busId] = unsub;
        }

        function renderMessage(container, data) {
            let dateStr = "Just now";
            if (data.timestamp) {
                const d = data.timestamp.toDate();
                dateStr = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) + ', ' + d.toLocaleDateString();
            }

            const item = document.createElement('div');
            item.className = "bg-slate-800/40 border-l-2 border-blue-500 pl-3 py-1";
            item.innerHTML = `
                <p class="text-slate-300 text-sm leading-relaxed mb-1">${data.message}</p>
                <p class="text-[10px] text-slate-500">${dateStr}</p>
            `;
            container.appendChild(item);
        }

        // Sidebar Toggle Logic
        window.toggleSidebar = function () {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('-translate-x-full');
        }
    </script>

    <script>
        // Initialize Map
        const map = L.map('map', { zoomControl: false }).setView([20.2961, 85.8245], 13);
        window.map = map;

        L.control.zoom({ position: 'bottomright' }).addTo(map);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap'
        }).addTo(map);

        const socket = io();

        // GPS & Routing State
        let userMarker = null;
        let routeLine = null;
        let targetBusId = null;
        let userLat = null, userLng = null;
        const tripCard = document.getElementById('trip-info-card');
        const tripEta = document.getElementById('trip-eta');
        const tripDist = document.getElementById('trip-dist');

        // User Location Icon
        const userIcon = L.divIcon({
            className: 'custom-user-icon',
            html: `<div class="w-4 h-4 bg-blue-500 rounded-full border-2 border-white shadow-lg pulse-ring"></div>`,
            iconSize: [16, 16],
            iconAnchor: [8, 8]
        });

        // Robust Geolocation Handling
        let watchId = null;

        // UI Helpers
        const gpsDot = document.getElementById('gps-dot');
        const gpsText = document.getElementById('gps-text');
        const serverDot = document.getElementById('server-dot');
        const serverText = document.getElementById('server-text');

        // Socket Connection Status
        socket.on('connect', () => {
            if (serverDot && serverText) {
                serverDot.className = "w-2 h-2 rounded-full bg-green-500";
                serverText.textContent = "Live";
            }
        });

        socket.on('disconnect', () => {
            if (serverDot && serverText) {
                serverDot.className = "w-2 h-2 rounded-full bg-red-500 animate-pulse";
                serverText.textContent = "Disconnected";
            }
        });

        function updateGpsStatus(state, msg) {
            if (!gpsText || !gpsDot) return;
            gpsText.textContent = msg;

            if (state === 'searching') {
                gpsDot.className = "w-2 h-2 rounded-full bg-yellow-500 animate-pulse";
            } else if (state === 'active') {
                gpsDot.className = "w-2 h-2 rounded-full bg-green-500";
            } else if (state === 'error') {
                gpsDot.className = "w-2 h-2 rounded-full bg-red-500";
            }
        }

        function startLocationTracking(highAccuracy = true) {
            if (watchId) navigator.geolocation.clearWatch(watchId);

            // Fail fast on High Accuracy (Indoor fix), give more time for Low Accuracy
            // usage: startLocationTracking(true) -> tries high acc, if fail -> tries low acc
            const gpsTimeout = highAccuracy ? 5000 : 30000;
            const maxAge = highAccuracy ? 0 : Infinity; // Accept any cached position for low accuracy

            const options = {
                enableHighAccuracy: highAccuracy,
                timeout: gpsTimeout,
                maximumAge: maxAge
            };

            console.log(`Starting GPS (High Acc: ${highAccuracy}, Timeout: ${gpsTimeout}ms)...`);
            updateGpsStatus('searching', `Locating (${highAccuracy ? 'High' : 'Low'})...`);

            watchId = navigator.geolocation.watchPosition(
                (pos) => {
                    // Success
                    userLat = pos.coords.latitude;
                    userLng = pos.coords.longitude;
                    updateUserMarker(userLat, userLng);
                    updateGpsStatus('active', 'GPS Active');

                    if (targetBusId) updateRoute();

                    // Hide error card if visible
                    const tripDist = document.getElementById('trip-dist');
                    if (tripDist && tripDist.textContent.includes("GPS")) {
                        document.getElementById('trip-info-card').classList.add('hidden');
                    }
                },
                (err) => {
                    console.warn(`GPS Error (${highAccuracy ? 'High' : 'Low'} Acc):`, err);

                    // If High Accuracy fails (Timeout/Error), try Low Accuracy automatically
                    if (highAccuracy) {
                        console.log("High accuracy failed, switching to low accuracy...");
                        startLocationTracking(false);
                        return;
                    }

                    // Show Error to User
                    updateGpsStatus('error', 'GPS Failed');

                    const tripCard = document.getElementById('trip-info-card');
                    const tripDist = document.getElementById('trip-dist');
                    const tripEta = document.getElementById('trip-eta');

                    tripCard.classList.remove('hidden');
                    tripEta.textContent = "âš ï¸";

                    if (err.code === 1) tripDist.textContent = "GPS Access Denied";
                    else if (err.code === 2) tripDist.textContent = "Location Unavailable";
                    else if (err.code === 3) tripDist.textContent = "GPS Signal Weak";
                    else tripDist.textContent = "GPS Error";
                },
                options
            );
        }

        // Initialize Geolocation
        if (navigator.geolocation) {
            // Start with Low Accuracy (Wifi/IP) for instant results
            // High Accuracy is often blocked/slow indoors
            startLocationTracking(false);
        } else {
            console.error("Browser does not support Geolocation");
        }

        function updateUserMarker(lat, lng) {
            if (userMarker) {
                userMarker.setLatLng([lat, lng]);
            } else {
                userMarker = L.marker([lat, lng], { icon: userIcon, zIndexOffset: 1000 }).addTo(map);
            }
        }

        // Routing Machine Control
        let routingControl = null;

        function startTrackingRoute(busId) {
            // Allow re-clicking to refresh UI even if already selected
            targetBusId = busId;
            tripCard.classList.remove('hidden');
            updateRoute();
        }

        function stopTrackingRoute() {
            targetBusId = null;
            tripCard.classList.add('hidden');

            if (routingControl) {
                map.removeControl(routingControl);
                routingControl = null;
            }
            // Remove legacy lines just in case
            if (routeLine) {
                map.removeLayer(routeLine);
                routeLine = null;
            }
            // Remove dashed fallback line
            if (window.fallbackLine) {
                map.removeLayer(window.fallbackLine);
                window.fallbackLine = null;
            }
        }

        function updateRoute() {
            if (!targetBusId || !markers[targetBusId]) return;

            // If we don't have user location yet
            if (!userLat) {
                tripEta.textContent = "--";
                tripDist.textContent = "Locating you...";
                tripCard.classList.remove('hidden');

                // Force GPS update check if stuck
                if (!watchId) startLocationTracking(false);
                return;
            }

            const busMarker = markers[targetBusId];

            // UI Update for Offline Status
            if (busMarker.isOffline) {
                tripCard.classList.add('grayscale');
                tripEta.style.color = '#94a3b8'; // Slate-400
                tripDist.innerText += " (Offline)";
            } else {
                tripCard.classList.remove('grayscale');
                tripEta.style.color = 'white';
            }

            const busLatLng = busMarker.getLatLng();

            // Swap: From Bus (Source) -> To User (Destination)
            const waypoints = [
                L.latLng(busLatLng.lat, busLatLng.lng),
                L.latLng(userLat, userLng)
            ];

            // Perform Instant Estimate (Haversine) & Draw Visual Fallback
            runFallbackRouting(busLatLng); // Uses simple line + math immediately

            // If control exists, update waypoints (attempting road match)
            if (routingControl) {
                if (window.routingTimer) clearTimeout(window.routingTimer);
                startRoutingTimer(busLatLng);
                routingControl.setWaypoints(waypoints);
            } else {
                // Initialize new control
                tripCard.classList.remove('hidden');

                if (window.routingTimer) clearTimeout(window.routingTimer);
                startRoutingTimer(busLatLng);

                try {
                    routingControl = L.Routing.control({
                        waypoints: waypoints,
                        router: L.Routing.osrmv1({
                            serviceUrl: 'https://router.project-osrm.org/route/v1',
                            profile: 'driving',
                            timeout: 5000,
                            routingOptions: {
                                alternatives: false,
                                steps: false,
                                overview: 'full'
                            }
                        }),
                        lineOptions: {
                            styles: [{ color: '#3b82f6', opacity: 0.8, weight: 6 }]
                        },
                        createMarker: function () { return null; },
                        addWaypoints: false,
                        draggableWaypoints: false,
                        fitSelectedRoutes: false,
                        show: false
                    }).addTo(map);

                    // Listeners
                    routingControl.on('routesfound', function (e) {
                        // Success! Remove dashed fallback line
                        if (window.fallbackLine) {
                            map.removeLayer(window.fallbackLine);
                            window.fallbackLine = null;
                        }
                        if (window.routingTimer) clearTimeout(window.routingTimer);

                        const routes = e.routes;
                        if (!routes || routes.length === 0) return;

                        const summary = routes[0].summary;
                        const durationMins = Math.ceil(summary.totalTime / 60);
                        const distanceKm = (summary.totalDistance / 1000).toFixed(1);

                        tripEta.textContent = `${durationMins} min`;
                        tripDist.textContent = `(${distanceKm} km)`;
                    });

                    routingControl.on('routingerror', function (e) {
                        if (window.routingTimer) clearTimeout(window.routingTimer);
                        // Do nothing visually, fallback line is already there from start
                        console.warn("Routing failed, keeping fallback line.");
                    });

                } catch (err) {
                    console.error("Routing Init Error:", err);
                    // Fallback line already drawn
                }
            }
        }

        // --- Routing Timeouts Helpers ---
        function startRoutingTimer(busLatLng) {
            window.routingTimer = setTimeout(() => {
                console.warn("OSRM Timeout (5s) - Keeping Direct Line");
                // Stop the routing spinner effect if any (not implemented, but good practice)
                // We just let the dashed line stay.
            }, 5000);
        }

        function runFallbackRouting(busLatLng) {
            const dist = map.distance([userLat, userLng], busLatLng);
            const distKm = (dist / 1000).toFixed(1);
            const timeMins = Math.ceil((distKm / 30) * 60);

            tripDist.textContent = `(${distKm} km)`;
            tripEta.textContent = `${timeMins} min`;

            // Draw Dashed Line (Visual Fallback)
            const waypoints = [
                [userLat, userLng],
                [busLatLng.lat, busLatLng.lng]
            ];

            if (window.fallbackLine) map.removeLayer(window.fallbackLine);

            window.fallbackLine = L.polyline(waypoints, {
                color: '#64748b', // Slate-500
                weight: 4,
                dashArray: '10, 10', // Dashed
                opacity: 0.7
            }).addTo(map);
        }


        const markers = {};
        const circles = {};
        let currentFilter = "";
        let offlineResult = null; // Store result from server search if offline

        function createBusIcon(busNo) {
            return L.divIcon({
                className: 'custom-div-icon',
                html: `<div style="position: relative;">
                        <div style="background-color: #3b82f6; width: 40px; height: 40px; border-radius: 50%; border: 3px solid #1e293b; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.5);">
                            <span style="font-size: 20px;">ðŸšŒ</span>
                        </div>
                        <div style="background: #1e293b; color: white; padding: 2px 8px; border-radius: 6px; font-weight: bold; font-size: 10px; position: absolute; top: -12px; left: 50%; transform: translateX(-50%); white-space: nowrap; border: 1px solid #475569; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                            ${busNo}
                        </div>
                       </div>`,
                iconSize: [40, 40],
                iconAnchor: [20, 20]
            });
        }

        function createEvIcon(busNo) {
            return L.divIcon({
                className: 'custom-div-icon',
                html: `<div style="position: relative;">
                        <div style="background-color: #10b981; width: 40px; height: 40px; border-radius: 50%; border: 3px solid #064e3b; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.5);">
                            <span style="font-size: 20px;">ðŸ›º</span>
                        </div>
                        <div style="background: #064e3b; color: white; padding: 2px 8px; border-radius: 6px; font-weight: bold; font-size: 10px; position: absolute; top: -12px; left: 50%; transform: translateX(-50%); white-space: nowrap; border: 1px solid #10b981; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                            EV
                        </div>
                       </div>`,
                iconSize: [40, 40],
                iconAnchor: [20, 20]
            });
        }

        const trackInput = document.getElementById('trackInput');
        const statusP = document.getElementById('tracking-status');

        function quickSearch(busNo) {
            trackInput.value = busNo;
            setFilter();
        }

        function setFilter() {
            const val = trackInput.value.trim().toUpperCase();
            currentFilter = val;
            offlineResult = null; // Reset offline result

            // Logic to auto-select matching bus
            let foundSid = null;
            if (val) {
                for (let sid in markers) {
                    if (markers[sid]._busNo === val) {
                        foundSid = sid;
                        break;
                    }
                }

                if (foundSid) {
                    startTrackingRoute(foundSid);
                    // Optional: Center map
                    // map.setView(markers[foundSid].getLatLng(), 15);
                }

                statusP.innerHTML = `<span>Filtered:</span> <b class="text-white">${val}</b> <button onclick="clearFilter()" class="ml-auto text-red-400 hover:text-red-300 text-xs underline">Reset</button>`;
                statusP.classList.remove('hidden');

                // Server Search (for offline/history check)
                socket.emit('search_bus', val);
            } else {
                clearFilter();
                stopTrackingRoute();
            }
            refreshMap(); // Refresh immediately for local filtering
        }

        window.clearFilter = function () {
            currentFilter = "";
            trackInput.value = "";
            offlineResult = null;
            statusP.classList.add('hidden');
            stopTrackingRoute();
            refreshMap();
        }

        // Listener for server search results
        socket.on('search_result', (data) => {
            if (data.status === 'offline' || data.status === 'not_found') {
                offlineResult = data;
                updateBusList(); // Force update to show offline card
            }
        });

        function refreshMap() {
            for (const [sid, marker] of Object.entries(markers)) {
                if (shouldShow(marker._busNo)) {
                    if (!map.hasLayer(marker)) map.addLayer(marker);
                    if (circles[sid] && !map.hasLayer(circles[sid])) map.addLayer(circles[sid]);
                } else {
                    if (map.hasLayer(marker)) map.removeLayer(marker);
                    if (circles[sid] && map.hasLayer(circles[sid])) map.removeLayer(circles[sid]);
                }
            }
            updateBusList();
        }

        function shouldShow(busNo) {
            // EVs are "Base Service" - Always show them regardless of filter
            if (busNo.startsWith("EV-")) return true;

            if (!currentFilter) return true;
            return busNo.includes(currentFilter);
        }



        function renderBusCard(sid, marker) {
            const isEv = marker._busNo.startsWith("EV-");
            const typeIcon = isEv ? "âš¡" : "ðŸšŒ";
            const typeColor = isEv ? "text-emerald-400" : "text-blue-100";
            const iconBg = isEv ? "bg-emerald-900/50" : "bg-blue-900/50";
            const activeColor = isEv ? "text-emerald-400" : "text-green-400";
            const activeBg = isEv ? "bg-emerald-500" : "bg-green-500";

            // Mask EV ID
            const displayId = isEv ? "Campus Shuttle" : marker._busNo;

            if (marker.isOffline) {
                // OFFLINE CARD
                const timeLabel = timeAgo(marker.disconnectTime);
                return `
                <div class="group flex items-center justify-between p-3 bg-slate-800/20 rounded-xl border border-dashed border-slate-600 grayscale opacity-80 cursor-pointer" onclick="zoomToBus('${sid}')">
                    <div class="flex items-center gap-3">
                        <div class="w-8 h-8 rounded-full bg-slate-700 flex items-center justify-center text-lg">ðŸ˜´</div>
                        <div>
                            <p class="font-bold text-sm text-slate-300">${displayId}</p>
                            <p class="text-[10px] text-slate-500 font-bold">
                                OFFLINE â€¢ ${timeLabel}
                            </p>
                        </div>
                    </div>
                </div>
                `;
            } else {
                // ACTIVE CARD
                return `
                <div class="group flex items-center justify-between p-3 bg-slate-800/50 rounded-xl border border-slate-700 hover:border-blue-500/50 transition-all cursor-pointer" onclick="zoomToBus('${sid}')">
                    <div class="flex items-center gap-3">
                        <div class="w-8 h-8 rounded-full ${iconBg} flex items-center justify-center text-lg">${typeIcon}</div>
                        <div>
                            <p class="font-bold text-sm ${typeColor}">${displayId}</p>
                            <p class="text-[10px] ${activeColor} font-bold flex items-center gap-1">
                                <span class="w-1.5 h-1.5 rounded-full ${activeBg} animate-pulse"></span>
                                ACTIVE NOW
                            </p>
                        </div>
                    </div>
                    <div class="text-xs text-blue-400 opacity-0 group-hover:opacity-100 transition-opacity">
                        LOCATE â†’
                    </div>
                </div>
                `;
            }
        }

        function updateBusList() {
            const listDiv = document.getElementById('bus-list');
            let visibleCount = 0;
            let html = '';

            // Separate Lists
            let evHtml = '';
            let busHtml = '';
            let hasEv = false;
            let hasBus = false;

            for (const [sid, marker] of Object.entries(markers)) {
                if (shouldShow(marker._busNo)) {
                    visibleCount++;
                    const card = renderBusCard(sid, marker);
                    if (marker._busNo.startsWith("EV-")) {
                        evHtml += card;
                        hasEv = true;
                    } else {
                        busHtml += card;
                        hasBus = true;
                    }
                }
            }

            if (hasEv) {
                html += `<div class="mb-2"><h3 class="text-[10px] bg-emerald-900/30 text-emerald-400 px-3 py-1 rounded-lg font-bold uppercase tracking-wider mb-2 border border-emerald-900/50">âš¡ EV Shuttles</h3><div class="space-y-2">${evHtml}</div></div>`;
            }

            if (hasBus) {
                html += `<div class="mb-2"><h3 class="text-[10px] bg-blue-900/30 text-blue-400 px-3 py-1 rounded-lg font-bold uppercase tracking-wider mb-2 border border-blue-900/50">ðŸšŒ Campus Buses</h3><div class="space-y-2">${busHtml}</div></div>`;
            }

            // Empty States
            if (visibleCount === 0) {
                if (currentFilter && !offlineResult) {
                    html = '<p class="text-xs text-slate-500 text-center py-4 italic">No matching vehicle found.</p>';
                } else if (!currentFilter) {
                    html = '<p class="text-xs text-slate-500 text-center py-4 italic">No active vehicles.</p>';
                }
            }

            listDiv.innerHTML = html;
        }

        window.zoomToBus = function (sid) {
            if (markers[sid] && map.hasLayer(markers[sid])) {
                const ll = markers[sid].getLatLng();
                map.flyTo(ll, 16);
                startTrackingRoute(sid); // Start Ola-style tracking
            }
        };

        socket.on('update_buses', (buses) => {
            for (const [sid, data] of Object.entries(buses)) updateMarker(sid, data);
            updateBusList();
        });

        socket.on('update_bus', (msg) => {
            updateMarker(msg.id, msg.data);
            updateBusList();
        });

        function createOfflineBusIcon(busNo) {
            return L.divIcon({
                className: 'custom-div-icon',
                html: `<div style="position: relative; filter: grayscale(100%); opacity: 0.7;">
                        <div style="background-color: #64748b; width: 40px; height: 40px; border-radius: 50%; border: 3px solid #1e293b; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.5);">
                            <span style="font-size: 20px;">ðŸšŒ</span>
                        </div>
                        <div style="background: #1e293b; color: white; padding: 2px 8px; border-radius: 6px; font-weight: bold; font-size: 10px; position: absolute; top: -12px; left: 50%; transform: translateX(-50%); white-space: nowrap; border: 1px solid #475569; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                            ${busNo}
                        </div>
                       </div>`,
                iconSize: [40, 40],
                iconAnchor: [20, 20]
            });
        }

        socket.on('bus_disconnected', (sid) => {
            if (markers[sid]) {
                const marker = markers[sid];
                marker.isOffline = true;
                marker.disconnectTime = new Date();

                // Update styling to offline
                marker.setIcon(createOfflineBusIcon(marker._busNo));

                // Remove accuracy circle
                if (circles[sid]) {
                    map.removeLayer(circles[sid]);
                    delete circles[sid];
                }

                console.log(`Bus ${marker._busNo} went offline at ${marker.disconnectTime.toLocaleTimeString()}`);
                updateBusList();
            }
        });

        // Helper to format "X min ago"
        function timeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            const interval = Math.floor(seconds / 60);
            if (interval < 1) return "Just now";
            if (interval === 1) return "1 min ago";
            return interval + " mins ago";
        }

        // Auto-update times every minute
        setInterval(updateBusList, 60000);

        function updateMarker(sid, data) {
            if (!data) return;
            const { lat, lng, bus_no, accuracy } = data;

            // FIX: Remove 'Ghost Markers' (Duplicate bus_no with different SID)
            for (const [existingSid, marker] of Object.entries(markers)) {
                if (marker._busNo === bus_no && existingSid !== sid) {
                    map.removeLayer(markers[existingSid]);
                    delete markers[existingSid];
                    if (circles[existingSid]) {
                        map.removeLayer(circles[existingSid]);
                        delete circles[existingSid];
                    }
                }
            }

            if (markers[sid]) {
                const marker = markers[sid];
                if (marker.isOffline) {
                    // Waking up! Reset to active state
                    marker.isOffline = false;
                    const isEv = bus_no.startsWith('EV-');
                    marker.setIcon(isEv ? createEvIcon(bus_no) : createBusIcon(bus_no));
                    console.log(`Bus ${bus_no} is back online!`);
                }
                marker.setLatLng([lat, lng]);
                marker._busNo = bus_no;
                if (circles[sid]) {
                    circles[sid].setLatLng([lat, lng]);
                    circles[sid].setRadius(accuracy || 0);
                }
            } else {
                const isEv = bus_no.startsWith('EV-');
                const marker = L.marker([lat, lng], { icon: isEv ? createEvIcon(bus_no) : createBusIcon(bus_no) });
                marker._busNo = bus_no;

                // Click to track route
                marker.on('click', () => {
                    startTrackingRoute(sid);
                });

                markers[sid] = marker;

                const circle = L.circle([lat, lng], {
                    radius: accuracy || 0,
                    color: '#60a5fa', // Blue-400
                    fillColor: '#3b82f6',
                    fillOpacity: 0.1,
                    weight: 1,
                    className: 'animate-pulse'
                });
                circles[sid] = circle;

                if (shouldShow(bus_no)) {
                    marker.addTo(map);
                    circle.addTo(map);
                }
            }

            // Update route if this is the target bus
            if (targetBusId === sid) {
                updateRoute();
            }
        }
    </script>
</body>

</html>